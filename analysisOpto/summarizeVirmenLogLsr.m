function logSumm = summarizeVirmenLogLsr(fp,saveto)

% logSumm = summarizeVirmenLogAllKinds(fp)
% analyzes behavioral data saved in virmen log structure
%
% INPUT
%   fp: cell array with full file paths (typically generated by fileCellArray.m)
%       must contain two fields, .behav (log from virmen PC) and 
%                                .lsr   (log from laser galvo PC)
%
% OUTPUT
%   logSumm: data structure with overall performance indicators and trial
%            data
%
% LP modified from previous code, jul 2017

%% where to save
if nargin < 2; saveto = analysisParams.pathForSpockLsrAnalysis; end

%% first check if log already exists
if ispc; bksl  = strfind(fp.behav,'\'); else bksl  = strfind(fp.behav,'/'); end
fnbehav        = fp.behav(bksl(end)+1:end); % file name

fprintf('   analyzing %s\n',fnbehav)
[thismouse,thisdate,thisgen] = mouseAndDateFromFileName(fnbehav);
fn                           = sprintf('behavLog_%s_%s.mat',thismouse,thisdate);

%%
cd(saveto)
if isempty(dir(thismouse)); mkdir(thismouse); end
cd(thismouse)
if ~isempty(dir(fn)) % try loading it first
   load(fn,'logSumm')
   runFlag = false;
else
   runFlag = true;
end
% runFlag = true;
% clear logSumm
if ~runFlag
  return
else
  
  %% load files from server
  load(fp.behav,'log')
  load(fp.lsr,'lsrlog')
  
  % to more easily access it, concatenate blocks
  lsrtemp = [];
  for ii = 1:numel(lsrlog.block)
    if ~isfield(lsrlog.block(ii).trial,'power')
      ntrials = numel(lsrlog.block(ii).trial);
      for iTrial = 1:ntrials 
        if sum(lsrlog.block(ii).trial(iTrial).locationIdx) == 0 
          lsrlog.block(ii).trial(iTrial).power = 0; 
        else
          lsrlog.block(ii).trial(iTrial).power = lsrlog.block(1).info.exptParams.power;
        end
      end
    end
    lsrtemp = [lsrtemp lsrlog.block(ii).trial(1:end-1)];
  end
    
  %% get general info first
  logSumm.info.mouseID      = log.animal.name;
  logSumm.info.protocol     = log.animal.protocol;
  logSumm.info.startTime    = log.session.start;
  logSumm.info.endTime      = log.session.end;
  logSumm.info.fn           = fn;
  logSumm.info.date         = thisdate;
  logSumm.info.behavFn      = fp.behav; % original file name
  logSumm.info.lsrFn        = fp.lsr; % original file name
  logSumm.info.genotype     = thisgen;
  logSumm.info.laserParams  = log.block(1).laserParams;
  
  exptParams = {'refIm','currIm','pxlPerMM','refPxl','galvofreq','grid'};
  for ii = 1:numel(exptParams)
    eval(sprintf('logSumm.info.%s = lsrlog.block(1).info.exptParams.%s;', exptParams{ii}, exptParams{ii}))
  end
  
  mazeInfo = feval(logSumm.info.protocol);
  for ii = 1:numel(log.block)
    if ~isempty(log.block(ii).trial)
      logSumm.info.mazes(ii) = log.block(ii).mazeID;
      try
        [~,logSumm.info.mazeLbl{ii}] = formatMazeName(mazeInfo(log.block(ii).mazeID));
      catch
        logSumm.info.mazeLbl{ii} = '';
      end
    end
  end

  % first couple of experiments don't have grid label but are all vctx
  % unilateral
  if ~isfield(logSumm.info.laserParams,'gridLabel')
    logSumm.info.laserParams.gridLabel = 'VctxUnilateralGrid.mat';
  end
  
  %% start compiling trials (drop block structure)
  logSumm.keyFrameLabels      = {'cue';'mem';'arm';'rew';'lsrOn';'lsrOff'};
  logSumm.meanPerfBlockCtrl   = [];
  logSumm.meanPerfBlock       = [];
  
  % trial info
  tc = 0; % overall counter to concatenate blocks
  for b = 1:numel(log.block) % main maze blocks
    
    % there is a bug that generates empty blocks
    if isempty(log.block(b).trial); continue; end
    
    % sometimes errors thrown in the end prevent proper block cleanup,
    % those will show up as 500-trial blocks
    ntrials = numel(log.block(b).trial);
    if ntrials == 500; ntrials = find([log.block(b).trial(:).iterations]>0,1,'last'); end
    
    for t = 1:ntrials % trials within block
      
      %% for user-enforced trial ending fill with nan
      if (strcmpi(char(log.block(b).trial(t).choice),'nil')                      ...
          && log.block(b).trial(t).time(log.block(b).trial(t).iterations) < 60 ) ...
          || isempty(log.block(b).trial(t).excessTravel)
        logSumm = fillwithnan(logSumm,tc,t);
        continue
      end
      
      %% laser info (on or off, power, location, epoch)
      logSumm.laserON(tc+t)       = logical(log.block(b).trial(t).laserON); 
      if logSumm.laserON(tc+t)
        if isfield(lsrtemp,'power')
          logSumm.power(tc+t)     = single(lsrtemp(tc+t).power);
        else
          logSumm.power(tc+t)     = single(logSumm.info.laserParams.power);
        end
      else
        logSumm.power(tc+t)       = single(0);
      end
      
      thislocation                = unique(log.block(b).trial(t).galvoPosIdx(log.block(b).trial(t).galvoPosIdx>0),'stable');
      if isempty(thislocation)
        logSumm.galvoPosIdx(tc+t) = single(0);
      else
        logSumm.galvoPosIdx(tc+t) = single(thislocation);
      end
      logSumm.laserEpochIdx(tc+t) = single(log.block(b).trial(t).laserEpoch);
      if logSumm.laserEpochIdx(tc+t) == 0
        logSumm.laserEpoch{tc+t}  = []; 
      elseif ~iscell(logSumm.info.laserParams.epoch) && logSumm.laserEpochIdx(tc+t) > 0
        logSumm.laserEpoch{tc+t}  = logSumm.info.laserParams.epoch;
      else
        logSumm.laserEpoch{tc+t}  = logSumm.info.laserParams.epoch{logSumm.laserEpochIdx(tc+t)};
      end
      
      
      %% first trial in the block?
      if t == 1
        logSumm.firstTrialofBlock(tc+t) = true;
      else
        logSumm.firstTrialofBlock(tc+t) = false;
      end
      
      %% which maze
      logSumm.currMaze(tc+t) = uint8(log.block(b).mazeID);
      
      % maze info
      logSumm.lCue(tc+t)     = single(mazeInfo(logSumm.currMaze(tc+t)).lCue);
      logSumm.lMemory(tc+t)  = single(mazeInfo(logSumm.currMaze(tc+t)).lMemory);
      logSumm.lStart(tc+t)   = single(mazeInfo(logSumm.currMaze(tc+t)).lStart);
      
      %% left or right trial
      if strcmpi(char(log.block(b).trial(t).trialType),'L')
        logSumm.trialType(tc+t) = single(analysisParams.leftCode);
      else
        logSumm.trialType(tc+t) = single(analysisParams.rightCode);
      end
      
      if ~isempty(log.block(b).trial(t).trialID);
        logSumm.stimID(tc+t) = int64(log.block(b).trial(t).trialID);
      else
        logSumm.stimID(tc+t) = nan;
      end
      
      %% animal went left or right
      if strcmpi(char(log.block(b).trial(t).choice),'L')
        logSumm.choice(tc+t) = single(analysisParams.leftCode);
      elseif strcmpi(char(log.block(b).trial(t).choice),'R')
        logSumm.choice(tc+t) = single(analysisParams.rightCode);
      else
        logSumm.choice(tc+t) = single(analysisParams.nilCode);
      end
      
      %% position, displacement, speed, view angle
      logSumm.excessTravel(tc+t) = single(log.block(b).trial(t).excessTravel);
      logSumm.pos{tc+t}          = single(log.block(b).trial(t).position); % position in Maze, cell array; [x y angle]
      logSumm.pos{tc+t}(:,3)     = -rad2deg(logSumm.pos{tc+t}(:,3)); % convert view angle to deg
      logSumm.displ{tc+t}        = diff(logSumm.pos{tc+t}); % displacement in Maze, cell array; [x y angle]
      if log.block(b).trial(t).iCueEntry > 0
        stemXYdispl              = logSumm.displ{tc+t}(log.block(b).trial(t).iCueEntry:log.block(b).trial(t).iArmEntry-1,1:2); % total XY displacement in Maze stem
      else
        stemXYdispl              = 0;
      end
      logSumm.stemDispl(tc+t)    = sum(sqrt(sum(stemXYdispl.^2,2))); % total displacement in stem
      if ~strcmpi(char(logSumm.info.protocol),'noworld')
        logSumm.stemDisplNorm(tc+t) ...
                                 = sum(sqrt(sum(stemXYdispl.^2,2)))./...
                                   (mazeInfo(logSumm.currMaze(tc+t)).lCue+mazeInfo(logSumm.currMaze(tc+t)).lMemory); % total displacement in stem normalized by stem numel
      else
        logSumm.stemDisplNorm(tc+t) ...
                                 = sum(sqrt(sum(stemXYdispl.^2,2)))./...
                                   (mazeInfo(1).lCue+mazeInfo(1).lMemory);
      end
      if log.block(b).trial(t).iCueEntry > 0
        if log.block(b).trial(t).iArmEntry > 0
          logSumm.speedStem(tc+t) ... 
                                 = logSumm.stemDispl(tc+t)/...
                                   (log.block(b).trial(t).time(log.block(b).trial(t).iArmEntry)-...
                                   log.block(b).trial(t).time(log.block(b).trial(t).iCueEntry)); % speed in maze stem
        else
          logSumm.speedStem(tc+t) ...
                                 = logSumm.stemDispl(tc+t)/...
                                   (log.block(b).trial(t).time(length(log.block(b).trial(t).position))-...
                                   log.block(b).trial(t).time(log.block(b).trial(t).iCueEntry)); % speed in maze stem
        end
      else
        logSumm.speedStem(tc+t)  = single(nan);
      end
      
      %% generative probability, reward, raw sensor readout etc
      logSumm.trialProb{tc+t}   = single(log.block(b).trial(t).trialProb);
      logSumm.rewardScale(tc+t) = single(log.block(b).trial(t).rewardScale);
      logSumm.sensorDots{tc+t}  = single(log.block(b).trial(t).sensorDots);
      
      %% cue info (deal with the fact that when cues don't appear cue onset iter will be = 0)
      % (if this is the case both position and onset will be filled with NaN)
      logSumm.cueOrder{tc+t}            = single(log.block(b).trial(t).cueCombo); % boolean, [left cues; right cues]
      [logSumm.cuePos_R{tc+t},Rorder]   = sort(single(log.block(b).trial(t).cuePos{2}));
      [logSumm.cuePos_L{tc+t},Lorder]   = sort(single(log.block(b).trial(t).cuePos{1}));
      
      idxR                              = single(log.block(b).trial(t).cueOnset{2}(Rorder));
      logSumm.cueOnset_R{tc+t}          = single(nan(1,numel(idxR)));
      logSumm.cueOnset_R{tc+t}(idxR>0)  = log.block(b).trial(t).time(idxR(idxR>0));
      logSumm.cuePos_R{tc+t}(idxR<1)    = single(nan);
      
      idxL                              = single(log.block(b).trial(t).cueOnset{1}(Lorder));
      logSumm.cueOnset_L{tc+t}          = single(nan(1,numel(idxL)));
      logSumm.cueOnset_L{tc+t}(idxL>0)  = log.block(b).trial(t).time(idxL(idxL>0));
      logSumm.cuePos_L{tc+t}(idxL<1)    = single(nan);
      
      idxR                              = single(log.block(b).trial(t).cueOffset{2}(Rorder));
      logSumm.cueOffset_R{tc+t}         = single(nan(1,numel(idxR)));
      logSumm.cueOffset_R{tc+t}(idxR>0) = log.block(b).trial(t).time(idxR(idxR>0));
      
      idxL                              = single(log.block(b).trial(t).cueOffset{1}(Lorder));
      logSumm.cueOffset_L{tc+t}         = single(nan(1,numel(idxL)));
      logSumm.cueOffset_L{tc+t}(idxL>0) = log.block(b).trial(t).time(idxL(idxL>0));
      
      logSumm.nCues_R(tc+t)             = single(numel(log.block(b).trial(t).cuePos{2}));
      logSumm.nCues_L(tc+t)             = single(numel(log.block(b).trial(t).cuePos{1}));
      
      try
        logSumm.cueDur_R{tc+t}  = single(log.block(b).trial(t).time(log.block(b).trial(t).cueOffset{2}) - ...
          log.block(b).trial(t).time(log.block(b).trial(t).cueOnset{2}));
        logSumm.cueDur_L{tc+t}  = single(log.block(b).trial(t).time(log.block(b).trial(t).cueOffset{1}) - ...
          log.block(b).trial(t).time(log.block(b).trial(t).cueOnset{1}));
      catch
        logSumm.cueDur_R{tc+t}  = single(inf); logSumm.cueDur_L{tc+t}  = single(inf);
      end
      
      %% timing info
      logSumm.time{tc+t}            = single(log.block(b).trial(t).time);
      logSumm.keyFrames{tc+t}       = single([log.block(b).trial(t).iCueEntry log.block(b).trial(t).iMemEntry ...
        log.block(b).trial(t).iArmEntry length(log.block(b).trial(t).position)]); % corresponds to logSumm.keyFrameLabels; [cue mem arm rew]
      logSumm.trialDur(tc+t)        = logSumm.time{tc+t}(length(log.block(b).trial(t).position));
      if log.block(b).trial(t).iCueEntry > 0
        if log.block(b).trial(t).iMemEntry > 0
          logSumm.trialDurCue(tc+t) = logSumm.time{tc+t}(log.block(b).trial(t).iMemEntry) - ...
            logSumm.time{tc+t}(log.block(b).trial(t).iCueEntry);
        else
          logSumm.trialDurCue(tc+t) = logSumm.time{tc+t}(length(log.block(b).trial(t).position)) - ...
            logSumm.time{tc+t}(log.block(b).trial(t).iCueEntry);
        end
        if log.block(b).trial(t).iMemEntry > 0 && log.block(b).trial(t).iArmEntry > 0
          logSumm.trialDurMem(tc+t) = logSumm.time{tc+t}(log.block(b).trial(t).iArmEntry) - ...
            logSumm.time{tc+t}(log.block(b).trial(t).iMemEntry);
        elseif log.block(b).trial(t).iMemEntry > 0 && log.block(b).trial(t).iArmEntry <= 0
          logSumm.trialDurMem(tc+t) = logSumm.time{tc+t}(length(log.block(b).trial(t).position)) - ...
            logSumm.time{tc+t}(log.block(b).trial(t).iMemEntry);
        else
          logSumm.trialDurMem(tc+t) = single(nan);
        end
      else
        logSumm.trialDurCue(tc+t)   = single(nan);
        logSumm.trialDurMem(tc+t)   = single(nan);
      end
      logSumm.trialDurFull(tc+t)    = single(log.block(b).trial(t).duration);
      try
        fr(tc+t)                    = mean(diff(logSumm.time{tc+t}(logSumm.keyFrames{tc+t}(2):logSumm.keyFrames{tc+t}(4))));
      catch
        fr(tc+t)                    = single(nan);
      end
    end
    
    %% performance in trial block
    if ~isempty(t)
      % mean performance by block, all trials
      ttype = logSumm.trialType(end-t+1:end);
      ch    = logSumm.choice(end-t+1:end);
      lsr   = logSumm.laserON(end-t+1:end);
      
      % mean performance by block, all trials
      perftemp                    = sum(ttype == ch)/numel(ttype);
      logSumm.meanPerfBlock       = [logSumm.meanPerfBlock ones(1,t)*perftemp];
      
      % mean performance by block, ctrl trials
      perftemp                    = sum(ttype(lsr==0) == ch(lsr==0))/sum(lsr==0);
      logSumm.meanPerfBlockCtrl   = [logSumm.meanPerfBlockCtrl ones(1,t)*perftemp];
      
      tc = tc + t; % udpate total number of trials
    end
  end
  
  %% calculate other variables from concatenated log
  if ~isfield(logSumm,'choice')
    logSumm               = fillwithnan(logSumm,0,1);
  end
  
  if isempty(logSumm.meanPerfBlockCtrl); logSumm.meanPerfBlockCtrl = nan; end
  if isempty(logSumm.meanPerfBlock);     logSumm.meanPerfBlock     = nan; end
  
  perftemp                 = sum(logSumm.trialType(logSumm.laserON==0 & logSumm.currMaze==max(logSumm.currMaze))  ...
    == logSumm.choice(logSumm.laserON==0 & logSumm.currMaze==max(logSumm.currMaze))) ...
    /sum(logSumm.laserON==0 & logSumm.currMaze==max(logSumm.currMaze));
  logSumm.meanPerfMainMaze = ones(1,numel(logSumm.trialType))*perftemp;
  
  %% effective durations (given specific sue positions
  logSumm.nCues_RminusL = logSumm.nCues_R-logSumm.nCues_L;
  logSumm.nCues_total   = logSumm.nCues_R+logSumm.nCues_L;
  logSumm.ntrials       = single(numel(logSumm.trialType));
  logSumm.protocolID    = uint8(ones(1,logSumm.ntrials).*find(strcmpi(analysisParams.behavProtType,char(logSumm.info.protocol))==1));
  
  maxr = cellfun(@max,logSumm.cuePos_R,'UniformOutput',false);
  maxl = cellfun(@max,logSumm.cuePos_L,'UniformOutput',false);
  minr = cellfun(@min,logSumm.cuePos_R,'UniformOutput',false);
  minl = cellfun(@min,logSumm.cuePos_L,'UniformOutput',false);
  for iT = 1:numel(maxr)
    if isempty(maxr{iT}) && isempty(maxl{iT})
      maxrl(iT) = logSumm.lCue(iT);
    else
      maxrl(iT) = max([maxr{iT} maxl{iT}]);
    end
    if isempty(minr{iT}) && isempty(minl{iT})
      minrl(iT) = 0;
    else
      minrl(iT) = min([minr{iT} minl{iT}]);
    end
  end
  logSumm.effectiveCueDurCm  = maxrl - minrl;
  logSumm.effectiveMemDurCm  = logSumm.lMemory + (logSumm.lCue - maxrl);
  
  maxr = cellfun(@max,logSumm.cueOnset_R,'UniformOutput',false);
  maxl = cellfun(@max,logSumm.cueOnset_L,'UniformOutput',false);
  minr = cellfun(@min,logSumm.cueOnset_R,'UniformOutput',false);
  minl = cellfun(@min,logSumm.cueOnset_L,'UniformOutput',false);
  for iT = 1:numel(maxr)
    if isempty(maxr{iT}) && isempty(maxl{iT})
      maxrl(iT) = logSumm.trialDurCue(iT);
    else
      maxrl(iT) = max([maxr{iT} maxl{iT}]);
    end
    if isempty(minr{iT}) && isempty(minl{iT})
      minrl(iT) = 0;
    else
      minrl(iT) = min([minr{iT} minl{iT}]);
    end
  end
  logSumm.effectiveCueDurSec = maxrl - minrl;
  logSumm.effectiveMemDurSec = logSumm.trialDurMem + (logSumm.trialDurCue - maxrl);
  
  
  %% average frame rate during maze navigation (excludes ITI)
  try logSumm.frameRate = nanmean(fr(fr~=0)); catch; logSumm.frameRate = single(nan); end
  
  %% save
  logSumm = orderfields(logSumm);
  save(sprintf('%s%s/%s',saveto,thismouse,fn),'logSumm')
end

end

%% fill with nan's in case of aborted trial
function logSumm = fillwithnan(logSumm,tc,t)
logSumm.laserON(tc+t)           = false;
logSumm.power(tc+t)             = single(0);
logSumm.galvoPosIdx(tc+t)       = single(0);
logSumm.laserEpochIdx(tc+t)     = single(0);
logSumm.laserEpoch{tc+t}        = [];
if t == 1; logSumm.firstTrialofBlock(tc+t) = true; else logSumm.firstTrialofBlock(tc+t) = false; end
logSumm.currMaze(tc+t)          = uint8(nan);
logSumm.lCue(tc+t)              = single(nan);
logSumm.lMemory(tc+t)           = single(nan);
logSumm.lStart(tc+t)            = single(nan);
logSumm.trialType(tc+t)         = single(nan);
logSumm.stimID(tc+t)            = int64(nan);
logSumm.choice(tc+t)            = single(nan);
logSumm.excessTravel(tc+t)      = single(nan);
logSumm.pos{tc+t}               = single([nan nan nan]);
logSumm.displ{tc+t}             = single([nan nan nan]);
logSumm.stemDispl(tc+t)         = single(nan);
logSumm.stemDisplNorm(tc+t)     = single(nan);
logSumm.speedStem(tc+t)         = single(nan);
logSumm.trialProb{tc+t}         = single(nan);
logSumm.rewardScale(tc+t)       = single(nan);
logSumm.sensorDots{tc+t}        = single([nan nan nan nan nan]);
logSumm.cueOrder{tc+t}          = single(nan);
logSumm.cuePos_R{tc+t}          = single(nan);
logSumm.cuePos_L{tc+t}          = single(nan);
logSumm.cueOnset_R{tc+t}        = single(nan);
logSumm.cueOnset_L{tc+t}        = single(nan);
logSumm.cueOffset_R{tc+t}       = single(nan);
logSumm.cueOffset_L{tc+t}       = single(nan);
logSumm.nCues_R(tc+t)           = single(nan);
logSumm.nCues_L(tc+t)           = single(nan);
logSumm.cueDur_R{tc+t}          = single(inf);
logSumm.cueDur_L{tc+t}          = single(inf);
logSumm.time{tc+t}              = single(nan);
logSumm.keyFrames{tc+t}         = single(nan);
logSumm.trialDur(tc+t)          = single(nan);
logSumm.trialDurCue(tc+t)       = single(nan);
logSumm.trialDurMem(tc+t)       = single(nan);
logSumm.trialDurFull(tc+t)      = single(nan);

end

