function logSumm = summarizeVirmenLogAllKinds(fp,saveto)

% logSumm = summarizeVirmenLogAllKinds(fp)
% analyzes behavioral data saved in virmen log structure
%
% INPUT
%   fp: cell array with full file paths (typically generated by fileCellArray.m)
%
% OUTPUT
%   logSumm: data structure with overall performance indicators and trial
%            data
%
% LP nov 2015

%% where to save
if nargin < 2
  saveto = [analysisParams.pathForSpock 'behavProcessed/'];
end

%% first check if log already exists
if ispc; bksl  = strfind(fp,'\'); else bksl  = strfind(fp,'/'); end
thisname       = fp(bksl(end)+1:end); % file name

fprintf('   analyzing %s\n',thisname)
[thismouse,thisdate,thisgen] = mouseAndDateFromFileName(thisname);
fn                           = sprintf('behavLog_%s_%s.mat',thismouse,thisdate);

%%
cd([analysisParams.pathForSpock 'behavProcessed/'])
cd(saveto)
if isempty(dir(thismouse))
   mkdir(thismouse)
end
cd(thismouse)
if ~isempty(dir(fn)) % try loading it first
   load(fn,'logSumm')
   runFlag = false;
else
   runFlag = true;
end
% runFlag = true;
% clear logSumm
if ~runFlag
%   logSumm = [];
  return
else
  
  %% load files from server
  load(fp,'log')
  
  % skip if view angle is locked or if movement transformations are not of
  % the common kind (i.e. linear gain 1 and exp gain for rotational velocity)
  if  strcmp(char(log.animal.virmenSensor), 'ViewAngleLocked') || ...
      ~isnan(log.animal.virmenRotationsPerRev)                 || ...
      log.animal.virmenDisplacementPerCm ~= 1
    
    logSumm = [];
    return
    
  end
  
  %% get general info first
  logSumm.info.mouseID      = log.animal.name;
  logSumm.info.protocol     = log.animal.protocol;
  logSumm.info.startTime    = log.session.start;
  logSumm.info.endTime      = log.session.end;
  logSumm.info.fn           = fn;
  logSumm.info.date         = thisdate;
  logSumm.info.behavFn      = thisname; % original file name
  
  mazeInfo = feval(logSumm.info.protocol);
  for ii = 1:length(log.block)
    if ~isempty(log.block(ii).trial)
      logSumm.info.mazes(ii) = log.block(ii).mazeID;
      try
        [~,logSumm.info.mazeLbl{ii}] = formatMazeName(mazeInfo(log.block(ii).mazeID));
      catch
        logSumm.info.mazeLbl{ii} = '';
      end
    end
  end
  
  % deduce genotype from mouse name
  logSumm.info.genotype = thisgen;
  
  %% start compiling trials (drop block structure)
  logSumm.keyFrameLabels      = {'cue';'mem';'arm';'rew'};
  logSumm.meanPerfBlockCtrl   = [];
  
  % trial info
  tc = 0; % overall counter to concatenate blocks
  for b = 1:numel(log.block) % main maze blocks
    
    % there is a bug that generates empty blocks
    if isempty(log.block(b).trial)
      continue
    end
    
    for t = 1:numel(log.block(b).trial) % trials within block
      
      % for user-enforced trial ending fill with nan
      if (strcmpi(char(log.block(b).trial(t).choice),'nil')                      ...
          && log.block(b).trial(t).time(log.block(b).trial(t).iterations) < 60 ) ...
          || isempty(log.block(b).trial(t).excessTravel)
        logSumm = fillwithnan(logSumm,tc,t);
        continue
      end
      
      % first trial in the block?
      if t == 1
        logSumm.firstTrialofBlock(tc+t) = true;
      else
        logSumm.firstTrialofBlock(tc+t) = false;
      end
      
      % which maze
      logSumm.currMaze(tc+t) = uint8(log.block(b).mazeID);
      
      % maze info
      logSumm.lCue(tc+t)     = single(mazeInfo(logSumm.currMaze(tc+t)).lCue);
      logSumm.lMemory(tc+t)  = single(mazeInfo(logSumm.currMaze(tc+t)).lMemory);
      logSumm.lStart(tc+t)   = single(mazeInfo(logSumm.currMaze(tc+t)).lStart);
      
      % left or right trial
      if strcmpi(char(log.block(b).trial(t).trialType),'L')
        logSumm.trialType(tc+t) = single(analysisParams.leftCode);
      else
        logSumm.trialType(tc+t) = single(analysisParams.rightCode);
      end
      
      if ~isempty(log.block(b).trial(t).trialID);
        logSumm.stimID(tc+t) = int64(log.block(b).trial(t).trialID);
      else
        logSumm.stimID(tc+t) = nan;
      end
      
      % laser info
      if isfield(log.block(b).trial(t),'laserON')
        logSumm.isLaserSess(tc+t)   = true; % boolean
        logSumm.laserON(tc+t)       = logical(log.block(b).trial(t).laserON); % boolean
      else
        logSumm.isLaserSess(tc+t)   = false; % boolean
        logSumm.laserON(tc+t)       = false; % boolean
      end
      
      % animal went left or right
      if strcmpi(char(log.block(b).trial(t).choice),'L')
        logSumm.choice(tc+t) = single(analysisParams.leftCode);
      elseif strcmpi(char(log.block(b).trial(t).choice),'R')
        logSumm.choice(tc+t) = single(analysisParams.rightCode);
      else
        logSumm.choice(tc+t) = single(analysisParams.nilCode);
      end
      
      % position, displacement, speed, view angle
      logSumm.excessTravel(tc+t) = single(log.block(b).trial(t).excessTravel);
      logSumm.pos{tc+t}          = single(log.block(b).trial(t).position); % position in Maze, cell array; [x y angle]
      logSumm.pos{tc+t}(:,3)     = -rad2deg(logSumm.pos{tc+t}(:,3)); % convert view angle to deg
      logSumm.displ{tc+t}        = diff(logSumm.pos{tc+t}); % displacement in Maze, cell array; [x y angle]
      if log.block(b).trial(t).iCueEntry > 0
        stemXYdispl            = logSumm.displ{tc+t}(log.block(b).trial(t).iCueEntry:log.block(b).trial(t).iArmEntry-1,1:2); % total XY displacement in Maze stem
      else
        stemXYdispl            = 0;
      end
      logSumm.stemDispl(tc+t)    = sum(sqrt(sum(stemXYdispl.^2,2))); % total displacement in stem
      if ~strcmpi(char(logSumm.info.protocol),'noworld')
        logSumm.stemDisplNorm(tc+t)= sum(sqrt(sum(stemXYdispl.^2,2)))./...
          (mazeInfo(logSumm.currMaze(tc+t)).lCue+mazeInfo(logSumm.currMaze(tc+t)).lMemory); % total displacement in stem normalized by stem length
      else
        logSumm.stemDisplNorm(tc+t)= sum(sqrt(sum(stemXYdispl.^2,2)))./...
          (mazeInfo(1).lCue+mazeInfo(1).lMemory);
      end
      if log.block(b).trial(t).iCueEntry > 0
        if log.block(b).trial(t).iArmEntry > 0
          logSumm.speedStem(tc+t)    = logSumm.stemDispl(tc+t)/...
            (log.block(b).trial(t).time(log.block(b).trial(t).iArmEntry)-...
            log.block(b).trial(t).time(log.block(b).trial(t).iCueEntry)); % speed in maze stem
        else
          logSumm.speedStem(tc+t)    = logSumm.stemDispl(tc+t)/...
            (log.block(b).trial(t).time(length(log.block(b).trial(t).position))-...
            log.block(b).trial(t).time(log.block(b).trial(t).iCueEntry)); % speed in maze stem
        end
      else
        logSumm.speedStem(tc+t)    = single(nan);
      end
      
      % generative probability, reward, raw sensor readout etc
      logSumm.trialProb{tc+t}   = single(log.block(b).trial(t).trialProb);
      logSumm.rewardScale(tc+t) = single(log.block(b).trial(t).rewardScale);
      logSumm.sensorDots{tc+t}  = single(log.block(b).trial(t).sensorDots);
      
      % cue info (deal with the fact that when cues don't appear cue onset iter will be = 0)
      % (if this is the case both position and onset will be filled with NaN)
      logSumm.cueOrder{tc+t}            = single(log.block(b).trial(t).cueCombo); % boolean, [left cues; right cues]
      [logSumm.cuePos_R{tc+t},Rorder]   = sort(single(log.block(b).trial(t).cuePos{2}));
      [logSumm.cuePos_L{tc+t},Lorder]   = sort(single(log.block(b).trial(t).cuePos{1}));
      
      idxR                              = single(log.block(b).trial(t).cueOnset{2}(Rorder));
      logSumm.cueOnset_R{tc+t}          = single(nan(1,numel(idxR)));
      logSumm.cueOnset_R{tc+t}(idxR>0)  = log.block(b).trial(t).time(idxR(idxR>0));
      logSumm.cuePos_R{tc+t}(idxR<1)    = single(nan);
      
      idxL                              = single(log.block(b).trial(t).cueOnset{1}(Lorder));
      logSumm.cueOnset_L{tc+t}          = single(nan(1,numel(idxL)));
      logSumm.cueOnset_L{tc+t}(idxL>0)  = log.block(b).trial(t).time(idxL(idxL>0));
      logSumm.cuePos_L{tc+t}(idxL<1)    = single(nan);
      
      idxR                              = single(log.block(b).trial(t).cueOffset{2}(Rorder));
      logSumm.cueOffset_R{tc+t}         = single(nan(1,numel(idxR)));
      logSumm.cueOffset_R{tc+t}(idxR>0) = log.block(b).trial(t).time(idxR(idxR>0));
      
      idxL                              = single(log.block(b).trial(t).cueOffset{1}(Lorder));
      logSumm.cueOffset_L{tc+t}         = single(nan(1,numel(idxL)));
      logSumm.cueOffset_L{tc+t}(idxL>0) = log.block(b).trial(t).time(idxL(idxL>0));
      
      logSumm.nCues_R(tc+t)             = single(numel(log.block(b).trial(t).cuePos{2}));
      logSumm.nCues_L(tc+t)             = single(numel(log.block(b).trial(t).cuePos{1}));
      
      try
        logSumm.cueDur_R{tc+t}  = single(log.block(b).trial(t).time(log.block(b).trial(t).cueOffset{2}) - ...
          log.block(b).trial(t).time(log.block(b).trial(t).cueOnset{2}));
        logSumm.cueDur_L{tc+t}  = single(log.block(b).trial(t).time(log.block(b).trial(t).cueOffset{1}) - ...
          log.block(b).trial(t).time(log.block(b).trial(t).cueOnset{1}));
      catch
        logSumm.cueDur_R{tc+t}  = single(inf); logSumm.cueDur_L{tc+t}  = single(inf);
      end
      
      % timing info
      logSumm.time{tc+t}          = single(log.block(b).trial(t).time);
      logSumm.keyFrames{tc+t}     = single([log.block(b).trial(t).iCueEntry log.block(b).trial(t).iMemEntry ...
        log.block(b).trial(t).iArmEntry length(log.block(b).trial(t).position)]); % corresponds to logSumm.keyFrameLabels; [cue mem arm rew]
      logSumm.trialDur(tc+t)      = logSumm.time{tc+t}(length(log.block(b).trial(t).position));
      if log.block(b).trial(t).iCueEntry > 0
        if log.block(b).trial(t).iMemEntry > 0
          logSumm.trialDurCue(tc+t)   = logSumm.time{tc+t}(log.block(b).trial(t).iMemEntry) - ...
            logSumm.time{tc+t}(log.block(b).trial(t).iCueEntry);
        else
          logSumm.trialDurCue(tc+t)   = logSumm.time{tc+t}(length(log.block(b).trial(t).position)) - ...
            logSumm.time{tc+t}(log.block(b).trial(t).iCueEntry);
        end
        if log.block(b).trial(t).iMemEntry > 0 && log.block(b).trial(t).iArmEntry > 0
          logSumm.trialDurMem(tc+t)   = logSumm.time{tc+t}(log.block(b).trial(t).iArmEntry) - ...
            logSumm.time{tc+t}(log.block(b).trial(t).iMemEntry);
        elseif log.block(b).trial(t).iMemEntry > 0 && log.block(b).trial(t).iArmEntry <= 0
          logSumm.trialDurMem(tc+t)   = logSumm.time{tc+t}(length(log.block(b).trial(t).position)) - ...
            logSumm.time{tc+t}(log.block(b).trial(t).iMemEntry);
        else
          logSumm.trialDurMem(tc+t)   = single(nan);
        end
      else
        logSumm.trialDurCue(tc+t)   = single(nan);
        logSumm.trialDurMem(tc+t)   = single(nan);
      end
      logSumm.trialDurFull(tc+t)  = single(log.block(b).trial(t).duration);
      try
        fr(tc+t)                = mean(diff(logSumm.time{tc+t}(logSumm.keyFrames{tc+t}(2):logSumm.keyFrames{tc+t}(4))));
      catch
        fr(tc+t)                = single(nan);
      end
    end
    
    if ~isempty(t);
      % mean performance by block, all trials
      ttype = logSumm.trialType(end-t+1:end);
      ch    = logSumm.choice(end-t+1:end);
      lsr   = logSumm.laserON(end-t+1:end);
      
      % mean performance by block, ctrl trials
      perftemp                    = sum(ttype(lsr==0) == ch(lsr==0))/sum(lsr==0);
      logSumm.meanPerfBlockCtrl   = [logSumm.meanPerfBlockCtrl ones(1,t)*perftemp];
      
      tc = tc + t; % udpate total number of trials
    end
  end
  
  if ~isfield(logSumm,'choice')
    logSumm               = fillwithnan(logSumm,0,1);
  end
  
  if isempty(logSumm.meanPerfBlockCtrl); logSumm.meanPerfBlockCtrl = nan; end
  
  perftemp                 = sum(logSumm.trialType(logSumm.laserON==0 & logSumm.currMaze==max(logSumm.currMaze))  ...
    == logSumm.choice(logSumm.laserON==0 & logSumm.currMaze==max(logSumm.currMaze))) ...
    /sum(logSumm.laserON==0 & logSumm.currMaze==max(logSumm.currMaze));
  logSumm.meanPerfMainMaze = ones(1,numel(logSumm.trialType))*perftemp;
  
  % effective durations (given specific sue positions
  logSumm.nCues_RminusL = logSumm.nCues_R-logSumm.nCues_L;
  logSumm.nCues_total   = logSumm.nCues_R+logSumm.nCues_L;
  logSumm.ntrials       = single(numel(logSumm.trialType));
  logSumm.protocolID    = uint8(ones(1,logSumm.ntrials).*find(strcmpi(analysisParams.behavProtType,char(logSumm.info.protocol))==1));
  
  maxr = cellfun(@max,logSumm.cuePos_R,'UniformOutput',false);
  maxl = cellfun(@max,logSumm.cuePos_L,'UniformOutput',false);
  minr = cellfun(@min,logSumm.cuePos_R,'UniformOutput',false);
  minl = cellfun(@min,logSumm.cuePos_L,'UniformOutput',false);
  for iT = 1:numel(maxr)
    maxrl(iT) = max([maxr{iT} maxl{iT}]);
    minrl(iT) = min([minr{iT} minl{iT}]);
  end
  logSumm.effectiveCueDurCm  = maxrl - minrl;
  logSumm.effectiveMemDurCm  = logSumm.lMemory + (logSumm.lCue - maxrl);
  
  maxr = cellfun(@max,logSumm.cueOnset_R,'UniformOutput',false);
  maxl = cellfun(@max,logSumm.cueOnset_L,'UniformOutput',false);
  minr = cellfun(@min,logSumm.cueOnset_R,'UniformOutput',false);
  minl = cellfun(@min,logSumm.cueOnset_L,'UniformOutput',false);
  for iT = 1:numel(maxr)
    maxrl(iT) = max([maxr{iT} maxl{iT}]);
    minrl(iT) = min([minr{iT} minl{iT}]);
  end
  logSumm.effectiveCueDurSec = maxrl - minrl;
  logSumm.effectiveMemDurSec = logSumm.trialDurMem + (logSumm.trialDurCue - maxrl);
  
  
  % average frame rate during maze navigation (excludes ITI)
  try logSumm.frameRate = nanmean(fr(fr~=0)); catch; logSumm.frameRate = single(nan); end
  
  
  logSumm = orderfields(logSumm);
  save(sprintf('%s%s/%s',saveto,thismouse,fn),'logSumm')
end

end

%% fill with nan's in case of aborted trial
function logSumm = fillwithnan(logSumm,tc,t)
if t == 1; logSumm.firstTrialofBlock(tc+t) = true; else logSumm.firstTrialofBlock(tc+t) = false; end
logSumm.currMaze(tc+t)          = uint8(nan);
logSumm.lCue(tc+t)              = single(nan);
logSumm.lMemory(tc+t)           = single(nan);
logSumm.lStart(tc+t)            = single(nan);
logSumm.trialType(tc+t)         = single(nan);
logSumm.stimID(tc+t)            = int64(nan);
try logSumm.isLaserSess(tc+t)   = logSumm.isLaserSess(tc+t-1); catch; logSumm.isLaserSess(tc+t)   = false; end
logSumm.laserON(tc+t)           = false;
logSumm.choice(tc+t)            = single(nan);
logSumm.excessTravel(tc+t)      = single(nan);
logSumm.pos{tc+t}               = single([nan nan nan]);
logSumm.displ{tc+t}             = single([nan nan nan]);
logSumm.stemDispl(tc+t)         = single(nan);
logSumm.stemDisplNorm(tc+t)     = single(nan);
logSumm.speedStem(tc+t)         = single(nan);
logSumm.trialProb{tc+t}         = single(nan);
logSumm.rewardScale(tc+t)       = single(nan);
logSumm.sensorDots{tc+t}        = single([nan nan nan nan nan]);
logSumm.cueOrder{tc+t}          = single(nan);
logSumm.cuePos_R{tc+t}          = single(nan);
logSumm.cuePos_L{tc+t}          = single(nan);
logSumm.cueOnset_R{tc+t}        = single(nan);
logSumm.cueOnset_L{tc+t}        = single(nan);
logSumm.cueOffset_R{tc+t}       = single(nan);
logSumm.cueOffset_L{tc+t}       = single(nan);
logSumm.nCues_R(tc+t)           = single(nan);
logSumm.nCues_L(tc+t)           = single(nan);
logSumm.cueDur_R{tc+t}          = single(inf);
logSumm.cueDur_L{tc+t}          = single(inf);
logSumm.time{tc+t}              = single(nan);
logSumm.keyFrames{tc+t}         = single(nan);
logSumm.trialDur(tc+t)          = single(nan);
logSumm.trialDurCue(tc+t)       = single(nan);
logSumm.trialDurMem(tc+t)       = single(nan);
logSumm.trialDurFull(tc+t)      = single(nan);

end

