function logSumm = summarizeVirmenLog(fp,protocol,figFlag)

% logSumm = summarizeVirmenLog(fp,figFlag)
% analyzes behavioral data saved in virmen log structure
%
% INPUT
%   fp: cell array with full file paths (typically generated by fileCellArray.m)
%   figFlag: plot session results and save to running .ps file
%
% OUTPUT
%   logSumm: data structure with overall performance indicators and trial
%            data
% 
% LP nov 2015

rootdir = '/Volumes/braininit/RigData/training/';
savepath = '/Users/lucas/Documents/Princeton/data/behav';

if nargin < 1
    fp       = [];
    figFlag  = 1;
    protocol = 'PoissonBlocksReboot3m';
elseif nargin == 1
    figFlag  = 1;
    protocol = 'PoissonBlocksReboot3m';
elseif nargin == 2
    figFlag  = 1;
end

if iscell(fp);       fp       = fp{1};       end
if iscell(protocol); protocol = protocol{1}; end
if iscell(protocol); protocol = protocol{1}; end

fprintf('   analyzing %s\n',fp)
if isempty(fp)
    uiopen(rootdir);
else
    load(fp,'log')
end

% load mazes info for proper plotting
mazes = eval(protocol);

% for badura mice
if ~isstruct(log.animal)
    temp = log.animal;
    log  = rmfield(log,'animal');
    log.animal.name = temp;
    log.animal.protocol = 'PoissonBlocksReboot'; %'PoissonTowersV2';
elseif isstruct(log.animal) && ~isfield(log.animal,'protocol')
    log.animal.protocol = 'PoissonBlocksReboot'; %'PoissonTowersV2';
end


fn = sprintf('%s_%04d%02d%02d_T%d_%s',log.animal.name,...
    log.session.start(1),log.session.start(2),log.session.start(3),...
    log.block(end).mainMazeID,char(log.animal.protocol));

cd(savepath)
if isempty(dir(log.animal.name))
    mkdir(log.animal.name)
end
cd(log.animal.name)
if ~isempty(dir([fn '.mat'])) % try loading it first
    load(fn,'logSumm')
    % plot Figure
%     if figFlag
%         try
%             plotFig(logSumm,mazes)
%             %close
%         catch
%             close
%             fprintf('\tproblem plotting figure\n')
%         end
%     end
    return
else
    try
    logSumm.perfSlide_bnsz  =   50; % trials for sliding-window performance
    logSumm.perfSlide_bnstp =   1;  % step size in trials
    
    logSumm.rightCode       =   1;
    logSumm.leftCode        =   0;
    logSumm.nilCode         =   -1;
    
    % general info
    logSumm.mouseID         =   log.animal.name;
    logSumm.date            =   log.session.start(1:3);
    logSumm.nBlocks         =   length(log.block);
    logSumm.mainMazeID      =   log.block(logSumm.nBlocks).mainMazeID;
    logSumm.protocol        =   char(log.animal.protocol);
    logSumm.keyFrameLabels  =   {'cue';'mem';'arm';'rew'};
    logSumm.warmUpMazes     =   [];
    logSumm.mainMazeBlocks  =   [];
    
    % figure out main and warm-up maze blocks
    for ii = 1:logSumm.nBlocks
        if log.block(ii).mazeID < logSumm.mainMazeID
            logSumm.warmUpMazes(end+1) = log.block(ii).mazeID;
        elseif log.block(ii).mazeID == logSumm.mainMazeID
            logSumm.mainMazeBlocks(end+1) = ii;
        end
    end
    
    % sometimes mouse only does warm-ups, in that case pick highest maze
    if isempty(logSumm.mainMazeBlocks)
        logSumm.mainMazeBlocks = length(log.block);
    end
    
    % trial info
    tc = 0; % overall counter to concatenate blocks
    for b = 1:length(logSumm.mainMazeBlocks) % main maze blocks
        for t = 1:length(log.block(logSumm.mainMazeBlocks(b)).trial) % trials within block
            % left or right trial
            if strcmpi(char(log.block(logSumm.mainMazeBlocks(b)).trial(t).trialType),'L')
                logSumm.trialType(tc+t) = logSumm.leftCode;
            else
                logSumm.trialType(tc+t) = logSumm.rightCode;
            end
            
            % for user-enforced trial ending
            if strcmpi(char(log.block(logSumm.mainMazeBlocks(b)).trial(t).choice),'nil') ...
                    || isempty(log.block(logSumm.mainMazeBlocks(b)).trial(t).choice)
                logSumm.choice(tc+t)        = logSumm.nilCode;
                logSumm.pos{tc+t}           = [nan nan nan];
                logSumm.displ{tc+t}         = [nan nan nan];
                logSumm.speedStem(tc+t)     = nan; 
                logSumm.cueOrder{tc+t}      = nan;
                logSumm.cuePos_R{tc+t}      = nan;
                logSumm.cuePos_L{tc+t}      = nan;
                logSumm.nCues_R(tc+t)       = nan;
                logSumm.nCues_L(tc+t)       = nan;
                logSumm.cueDur_R{tc+t}      = inf;
                logSumm.cueDur_L{tc+t}      = inf;
                logSumm.time{tc+t}          = nan;
                logSumm.keyFrames{tc+t}     = nan;
                logSumm.trialDur(tc+t)      = nan;
                logSumm.trialDurCue(tc+t)   = nan;
                logSumm.trialDurMem(tc+t)   = nan;
                logSumm.trialDurFull(tc+t)  = nan;
                fr(tc+t)                    = nan;
                continue
            end
            
            % animal went left or right
            if strcmpi(char(log.block(logSumm.mainMazeBlocks(b)).trial(t).choice),'L')
                logSumm.choice(tc+t) = logSumm.leftCode;
            else
                logSumm.choice(tc+t) = logSumm.rightCode;
            end
            
            % position, displacement, speed, view angle
            logSumm.pos{tc+t}       = log.block(logSumm.mainMazeBlocks(b)).trial(t).position; % position in Maze, cell array; [x y angle]
            logSumm.pos{tc+t}(:,3)  = rad2deg(logSumm.pos{tc+t}(:,3)); % convert view angle to deg
            logSumm.displ{tc+t}     = diff(logSumm.pos{tc+t}); % displacement in Maze, cell array; [x y angle]
            stemXYdispl             = logSumm.displ{tc+t}(log.block(logSumm.mainMazeBlocks(b)).trial(t).iCueEntry:log.block(logSumm.mainMazeBlocks(b)).trial(t).iArmEntry-1,1:2); % total XY displacement in Maze stem
            stemDispl               = sum(sqrt(sum(stemXYdispl.^2,2))); % total displacement in stem
            try
            logSumm.speedStem(tc+t) = stemDispl/...
                (log.block(logSumm.mainMazeBlocks(b)).trial(t).time(log.block(logSumm.mainMazeBlocks(b)).trial(t).iArmEntry)-...
                log.block(logSumm.mainMazeBlocks(b)).trial(t).time(log.block(logSumm.mainMazeBlocks(b)).trial(t).iCueEntry)); % speed in maze stem
            catch
                keyboard
            end
            % cue info
            logSumm.cueOrder{tc+t}  = log.block(logSumm.mainMazeBlocks(b)).trial(t).cueCombo; % boolean, [left cues; right cues]
            logSumm.cuePos_R{tc+t}  = log.block(logSumm.mainMazeBlocks(b)).trial(t).cuePos{2};
            logSumm.cuePos_L{tc+t}  = log.block(logSumm.mainMazeBlocks(b)).trial(t).cuePos{1};
            logSumm.nCues_R(tc+t)   = length(log.block(logSumm.mainMazeBlocks(b)).trial(t).cuePos{2});
            logSumm.nCues_L(tc+t)   = length(log.block(logSumm.mainMazeBlocks(b)).trial(t).cuePos{1});
            try
                logSumm.cueDur_R{tc+t}  = log.block(logSumm.mainMazeBlocks(b)).trial(t).time(log.block(logSumm.mainMazeBlocks(b)).trial(t).cueOffset{2}) - ...
                    log.block(logSumm.mainMazeBlocks(b)).trial(t).time(log.block(logSumm.mainMazeBlocks(b)).trial(t).cueOnset{2});
                logSumm.cueDur_L{tc+t}  = log.block(logSumm.mainMazeBlocks(b)).trial(t).time(log.block(logSumm.mainMazeBlocks(b)).trial(t).cueOffset{1}) - ...
                    log.block(logSumm.mainMazeBlocks(b)).trial(t).time(log.block(logSumm.mainMazeBlocks(b)).trial(t).cueOnset{1});
            catch
                logSumm.cueDur_R{tc+t}  = inf; logSumm.cueDur_L{tc+t}  = inf;
            end
            
            % timing info
            logSumm.time{tc+t}          = log.block(logSumm.mainMazeBlocks(b)).trial(t).time;
            logSumm.keyFrames{tc+t}     = [log.block(logSumm.mainMazeBlocks(b)).trial(t).iCueEntry log.block(logSumm.mainMazeBlocks(b)).trial(t).iMemEntry ...
                log.block(logSumm.mainMazeBlocks(b)).trial(t).iArmEntry length(log.block(logSumm.mainMazeBlocks(b)).trial(t).position)]; % corresponds to logSumm.keyFrameLabels; [cue mem arm rew]
            logSumm.trialDur(tc+t)      = logSumm.time{tc+t}(length(log.block(logSumm.mainMazeBlocks(b)).trial(t).position));
            logSumm.trialDurCue(tc+t)   = logSumm.time{tc+t}(log.block(logSumm.mainMazeBlocks(b)).trial(t).iMemEntry) - ...
                logSumm.time{tc+t}(log.block(logSumm.mainMazeBlocks(b)).trial(t).iCueEntry);
            logSumm.trialDurMem(tc+t)   = logSumm.time{tc+t}(log.block(logSumm.mainMazeBlocks(b)).trial(t).iArmEntry) - ...
                logSumm.time{tc+t}(log.block(logSumm.mainMazeBlocks(b)).trial(t).iMemEntry);
            logSumm.trialDurFull(tc+t)  = log.block(logSumm.mainMazeBlocks(b)).trial(t).duration;
            fr(tc+t)                    = mean(diff(logSumm.time{tc+t}(logSumm.keyFrames{tc+t}(4))-logSumm.time{tc+t}(logSumm.keyFrames{tc+t}(2))));
        end
        if ~isempty(t); tc = tc + t; end% udpate total number of trials
    end

    logSumm.nCues_RminusL = logSumm.nCues_R-logSumm.nCues_L;
    logSumm.ntrials       = length(logSumm.trialType);
    
    % average frame rate during maze navigation (excludes ITI)
    logSumm.frameRate     = nanmean(fr);
    
    % performance
    % overall performance
    logSumm.perfOverall = sum(logSumm.trialType == logSumm.choice)./logSumm.ntrials;
    logSumm.biasOverall = abs((sum(logSumm.trialType == logSumm.choice & ...
        logSumm.trialType == logSumm.rightCode)/sum(logSumm.trialType == logSumm.rightCode)) - ...
        (sum(logSumm.trialType == logSumm.choice & ...
        logSumm.trialType == logSumm.leftCode)/sum(logSumm.trialType == logSumm.leftCode)));
    
    % sliding window
    logSumm.meadianDiff      = round(median(abs(logSumm.nCues_RminusL))); % 50% prctile of trial difficulty
    logSumm.perfSlide        = [];
    logSumm.biasSlide        = [];
    logSumm.perfSlide_easy   = [];
    logSumm.perfSlide_hard   = [];
    for ii = 1:logSumm.perfSlide_bnstp:logSumm.ntrials-logSumm.perfSlide_bnsz
        idx         =   ii:ii+logSumm.perfSlide_bnsz;
        easyIdx     =   idx(1)-1+find(abs(logSumm.nCues_RminusL(idx)) >= logSumm.meadianDiff);
        hardIdx     =   idx(1)-1+find(abs(logSumm.nCues_RminusL(idx)) <  logSumm.meadianDiff);
        logSumm.perfSlide(end+1)      = sum(logSumm.trialType(idx) == logSumm.choice(idx))./length(idx);
        logSumm.perfSlide_easy(end+1) = sum(logSumm.trialType(easyIdx) == logSumm.choice(easyIdx))./length(easyIdx);
        logSumm.perfSlide_hard(end+1) = sum(logSumm.trialType(hardIdx) == logSumm.choice(hardIdx))./length(hardIdx);
        logSumm.biasSlide(end+1)      = abs((sum(logSumm.trialType(idx) == logSumm.choice(idx) & ...
            logSumm.trialType(idx) == logSumm.rightCode)/sum(logSumm.trialType(idx) == logSumm.rightCode)) - ...
            (sum(logSumm.trialType(idx) == logSumm.choice(idx) & ...
            logSumm.trialType(idx) == logSumm.leftCode)/sum(logSumm.trialType(idx) == logSumm.leftCode)));
    end
    
    % psychometric curve from raw data (all diffs and binned)
    logSumm.perfPsych_xaxis     = unique(logSumm.nCues_RminusL);
    logSumm.perfPsych           = zeros(size(logSumm.perfPsych_xaxis));
    logSumm.perfPsych_bins      = -15:3:15;
    logSumm.perfPsych_xaxisBins = logSumm.perfPsych_bins+mode(diff(logSumm.perfPsych_bins))/2;
    logSumm.perfPsych_binned    = zeros(size(logSumm.perfPsych_xaxis));
    % all #r - #l, fraction went right
    for ii = 1:length(logSumm.perfPsych_xaxis)
        logSumm.perfPsych(ii) = sum(logSumm.choice(logSumm.nCues_RminusL==logSumm.perfPsych_xaxis(ii)) == logSumm.rightCode)/...
            sum(logSumm.nCues_RminusL==logSumm.perfPsych_xaxis(ii));
    end
    % binned
    for ii = 1:length(logSumm.perfPsych_bins)-1
        logSumm.perfPsych_binned(ii) =  sum(logSumm.choice(logSumm.nCues_RminusL>=logSumm.perfPsych_bins(ii) & ...
            logSumm.nCues_RminusL<logSumm.perfPsych_bins(ii+1)) == logSumm.rightCode)/...
            sum(logSumm.nCues_RminusL>=logSumm.perfPsych_bins(ii) & ...
            logSumm.nCues_RminusL<logSumm.perfPsych_bins(ii+1));
    end
    
    % psychometric curve using jeffrey's method (all diffs and binned)
    logSumm.perfPsychJ_xaxis     = unique(logSumm.nCues_RminusL);
    logSumm.perfPsychJ           = zeros(size(logSumm.perfPsych_xaxis));
    logSumm.perfPsychJSEM        = zeros(length(logSumm.perfPsych_xaxis),2);
    logSumm.perfPsychJ_bins      = -15:3:15;
    logSumm.perfPsychJ_xaxisBins = logSumm.perfPsych_bins+mode(diff(logSumm.perfPsych_bins))/2;
    logSumm.perfPsychJ_binned    = zeros(size(logSumm.perfPsychJ_xaxisBins));
    logSumm.perfPsychJ_binnedSEM = zeros(length(logSumm.perfPsychJ_xaxisBins),2);
    % all #r - #l, fraction went right
    for ii = 1:length(logSumm.perfPsychJ_xaxis)
        [logSumm.perfPsychJ(ii),logSumm.perfPsychJSEM(ii,:)] = ...
            binointerval(sum(logSumm.choice(logSumm.nCues_RminusL==logSumm.perfPsych_xaxis(ii)) == logSumm.rightCode),...
            sum(logSumm.nCues_RminusL==logSumm.perfPsych_xaxis(ii)),.325);
    end
    % binned
    for ii = 1:length(logSumm.perfPsych_bins)-1
        [logSumm.perfPsychJ_binned(ii),logSumm.perfPsychJ_binnedSEM(ii,:)] = ...
            binointerval(sum(logSumm.choice(logSumm.nCues_RminusL>=logSumm.perfPsych_bins(ii) & ...
            logSumm.nCues_RminusL<logSumm.perfPsych_bins(ii+1)) == logSumm.rightCode),...
            sum(logSumm.nCues_RminusL>=logSumm.perfPsych_bins(ii) & ...
            logSumm.nCues_RminusL<logSumm.perfPsych_bins(ii+1)),.325);
    end
    
    
    % view angle as a function of maze position, trajectory
    logSumm.yposBinsFine    = -30:mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory+30;
    logSumm.yposBinsCoarse  = -20:40:mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory+20;
    logSumm.XposR           = nan(logSumm.ntrials,length(logSumm.yposBinsFine)-1);
    logSumm.XposL           = nan(logSumm.ntrials,length(logSumm.yposBinsFine)-1);
    logSumm.viewR           = nan(logSumm.ntrials,length(logSumm.yposBinsFine)-1);
    logSumm.viewL           = nan(logSumm.ntrials,length(logSumm.yposBinsFine)-1);
    logSumm.viewBinnedR     = nan(logSumm.ntrials,length(logSumm.yposBinsCoarse)-1);
    logSumm.viewBinnedL     = nan(logSumm.ntrials,length(logSumm.yposBinsCoarse)-1);
    for ii = 1:logSumm.ntrials
        if logSumm.choice(ii) == logSumm.rightCode
            for jj = 1:length(logSumm.yposBinsFine)-1
                logSumm.XposR(ii,jj) = ...
                    mean(logSumm.pos{ii}(logSumm.pos{ii}(:,2)>=logSumm.yposBinsFine(jj) & ...
                    logSumm.pos{ii}(:,2)<logSumm.yposBinsFine(jj+1),1));
                logSumm.viewR(ii,jj) = ...
                    mean(logSumm.pos{ii}(logSumm.pos{ii}(:,2)>=logSumm.yposBinsFine(jj) & ...
                    logSumm.pos{ii}(:,2)<logSumm.yposBinsFine(jj+1),3));
            end
            for jj = 1:length(logSumm.yposBinsCoarse)-1
                logSumm.viewBinnedR(ii,jj) = ...
                    mean(logSumm.pos{ii}(logSumm.pos{ii}(:,2)>=logSumm.yposBinsCoarse(jj) & ...
                    logSumm.pos{ii}(:,2)<logSumm.yposBinsCoarse(jj+1),3));
            end
        else
            for jj = 1:length(logSumm.yposBinsFine)-1
                logSumm.XposL(ii,jj) = ...
                    mean(logSumm.pos{ii}(logSumm.pos{ii}(:,2)>=logSumm.yposBinsFine(jj) & ...
                    logSumm.pos{ii}(:,2)<logSumm.yposBinsFine(jj+1),1));
                logSumm.viewL(ii,jj) = ...
                    mean(logSumm.pos{ii}(logSumm.pos{ii}(:,2)>=logSumm.yposBinsFine(jj) & ...
                    logSumm.pos{ii}(:,2)<logSumm.yposBinsFine(jj+1),3));
            end
            for jj = 1:length(logSumm.yposBinsCoarse)-1
                logSumm.viewBinnedL(ii,jj) = ...
                    mean(logSumm.pos{ii}(logSumm.pos{ii}(:,2)>=logSumm.yposBinsCoarse(jj) & ...
                    logSumm.pos{ii}(:,2)<logSumm.yposBinsCoarse(jj+1),3));
            end
        end
        
    end
    logSumm.XposAvgR = nanmean(logSumm.XposR);
    logSumm.XposAvgL = nanmean(logSumm.XposL);
    % ignore bottom and top 10% prctile for avg view angle
    tempR = logSumm.viewR;
    tempR(logSumm.viewR<prctile(reshape(logSumm.viewR,[1 numel(logSumm.viewR)]),10) | logSumm.viewR>prctile(reshape(logSumm.viewR,[1 numel(logSumm.viewR)]),90))=nan;
    tempL = logSumm.viewL;
    tempL(logSumm.viewL<prctile(reshape(logSumm.viewL,[1 numel(logSumm.viewL)]),10) | logSumm.viewL>prctile(reshape(logSumm.viewL,[1 numel(logSumm.viewL)]),90))=nan;
    logSumm.viewAvgR = nanmedian(tempR);
    logSumm.viewAvgL = nanmedian(tempL);
    
    % binned distributions of view angles as a function of y, overlap
    logSumm.viewCoarseBins     = -70:5:70;
    logSumm.viewR_coarseBinned = zeros(length(logSumm.yposBinsCoarse)-1,length(logSumm.viewCoarseBins));
    logSumm.viewL_coarseBinned = zeros(length(logSumm.yposBinsCoarse)-1,length(logSumm.viewCoarseBins));
    % histograms by bins 
    for jj = 1:length(logSumm.yposBinsCoarse)-1
        logSumm.viewL_coarseBinned(jj,:) = ...
            histc(logSumm.viewBinnedL(logSumm.choice==logSumm.leftCode,jj),logSumm.viewCoarseBins);
        logSumm.viewL_coarseBinned(jj,:) = logSumm.viewL_coarseBinned(jj,:)./max(logSumm.viewL_coarseBinned(jj,:));
        
        logSumm.viewR_coarseBinned(jj,:) = ...
            histc(logSumm.viewBinnedR(logSumm.choice==logSumm.rightCode,jj),logSumm.viewCoarseBins);
        logSumm.viewR_coarseBinned(jj,:) = logSumm.viewR_coarseBinned(jj,:)./max(logSumm.viewR_coarseBinned(jj,:));
        
        % overlap in distributions
        tempL         = trapz(logSumm.viewCoarseBins(~isnan(logSumm.viewL_coarseBinned(jj,:))),...
                        logSumm.viewL_coarseBinned(jj,~isnan(logSumm.viewL_coarseBinned(jj,:)))); % AUC L
        tempR         = trapz(logSumm.viewCoarseBins(~isnan(logSumm.viewR_coarseBinned(jj,:))),...
                        logSumm.viewR_coarseBinned(jj,~isnan(logSumm.viewR_coarseBinned(jj,:)))); % AUC L
        tempidx       = find(~isnan(logSumm.viewR_coarseBinned(jj,:)) & ~isnan(logSumm.viewL_coarseBinned(jj,:)));
        tempIntersect = trapz(logSumm.viewCoarseBins(tempidx),abs(logSumm.viewR_coarseBinned(jj,tempidx)-logSumm.viewL_coarseBinned(jj,tempidx))); % AUC R-L
        logSumm.viewOverlap_coarseBinned(jj) = 1-(tempIntersect/(tempL+tempR));
    end
    
    % save
    cd(savepath)
    if isempty(dir(logSumm.mouseID))
        mkdir(logSumm.mouseID)
    end
    cd([savepath '/' logSumm.mouseID])
    save(fn,'logSumm')
    
    % plot Figure
    if figFlag
        plotFig(logSumm,mazes)
        close
    end
    catch
        
        return
    end
    
    %cd(savepath)
end

end

%% nested function to plot data and save to .ps file
function plotFig(logSumm,mazes)
ss = get(groot,'screensize');
ss = ss(3:4);
figure    ('Name',               sprintf('%s - maze T%d, %04d%02d%02d',...
    logSumm.mouseID,logSumm.mainMazeID,logSumm.date(1),logSumm.date(2),logSumm.date(3)),...
    'NumberTitle',        'off',...
    'Position',           round([ss(1)*.1 ss(2)*.1 ss(1)*.8 ss(2)*.8]));

% plot psychometric curve
subplot(3,3,1)
errorbar(logSumm.perfPsychJ_xaxisBins,logSumm.perfPsychJ_binned,...
    logSumm.perfPsychJ_binnedSEM(:,1)'+logSumm.perfPsychJ_binned,...
    logSumm.perfPsychJ_binnedSEM(:,2)'-logSumm.perfPsychJ_binned,...
    'ko-','markersize',6,'markerfacecolor','k','linewidth',1)
box off; set(gca,'fontsize',10)
xlim([-16 16]); ylim([-.05 1.05])
xlabel('#R - #L patches','fontsize',12)
ylabel('Fraction went right','fontsize',12)
title('Psychometric curve','fontsize',13)

% plot sliding window performance (annotate overall)
subplot(3,3,2); hold on
if ~isempty(logSumm.perfSlide)
    xaxis = logSumm.perfSlide_bnsz+(1:length(logSumm.perfSlide));
    plot(xaxis,logSumm.perfSlide,'k-','linewidth',1)
    plot(xaxis,logSumm.perfSlide_easy,'-','color',[.7 .7 .7],'linewidth',1)
    plot(xaxis,logSumm.perfSlide_hard,'-','color',[.4 .4 .4],'linewidth',1)
    plot(xaxis,logSumm.biasSlide,'-','color',[29 178 6]./255,'linewidth',1)
    ylim([-.05 1.05]); xl = get(gca,'xlim');
    text(xl(1)*1.2,0.3,sprintf('%% correct: %1.1f\nbias: %1.2f',logSumm.perfOverall*100,logSumm.biasOverall))
    cls = {[0 0 0],[.7 .7 .7],[.4 .4 .4],[29 178 6]./255};
    lbls = {'overall','easy','hard','bias'};
    for ii = 1:4
        text(xaxis(end)*.9,1.1-.07*ii,lbls{ii},'color',cls{ii},'fontsize',9)
    end
    %legend({'overall','easy','hard','bias'},'location','best')
else
    xlim([0 1])
    ylim([-.05 1.05])
    text(.2,0.3,sprintf('%% correct: %1.1f\nbias: %1.2f',logSumm.perfOverall*100,logSumm.biasOverall))
end
box off; set(gca,'fontsize',10)
xlabel('trial #','fontsize',12)
ylabel('Fraction','fontsize',12)
title(sprintf('%04d%02d%02d T%d\nOverall performance',logSumm.date(1),...
    logSumm.date(2),logSumm.date(3),logSumm.mainMazeID),'fontsize',13)

% plot running speed distribution
subplot(3,3,3)
histogram(logSumm.speedStem,'binwidth',5)
box off; set(gca,'fontsize',10)
yl = get(gca,'ylim'); xl = get(gca,'xlim');
text(xl(1)*1.1,yl(2)*.9,sprintf('mean = %1.1f',nanmean(logSumm.speedStem)));
xlabel('running speed (cm/s)','fontsize',12)
ylabel('Num. trials','fontsize',12)
title('Speed','fontsize',13)

% plot raw trajectories on T maze
subplot(3,3,[4 7]); hold on
plot([-5 5],[0 0],'-','color',[.7 .7 .7])
plot([-5 5],[-mazes(logSumm.mainMazeID).lStart -mazes(logSumm.mainMazeID).lStart],'-','color',[.7 .7 .7])
plot([-5 5],[mazes(logSumm.mainMazeID).lCue mazes(logSumm.mainMazeID).lCue],'-','color',[.7 .7 .7])
plot([-5 5],[mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory...
    mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
plot([-16 -5],[mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory ...
    mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
plot([5 16],[mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory ...
    mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
plot([-16 16],20+[mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory ...
    mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
plot([-16 -16],[mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory ...
    20+mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
plot([16 16],[mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory ...
    20+mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
plot([-5 -5],[-mazes(logSumm.mainMazeID).lStart ...
    mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
plot([5 5],[-mazes(logSumm.mainMazeID).lStart ...
    mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
for ii = 1:logSumm.ntrials
    if logSumm.choice(ii) == logSumm.rightCode
        plot(logSumm.pos{ii}(:,1),logSumm.pos{ii}(:,2),'linewidth',.25,'color',[.7 .7 1])
    else
        plot(logSumm.pos{ii}(:,1),logSumm.pos{ii}(:,2),'linewidth',.25,'color',[1 .7 .7])
    end
end
plot(logSumm.XposAvgR,logSumm.yposBinsFine(1:end-1)+mode(diff(logSumm.yposBinsFine))/2,'b-')
plot(logSumm.XposAvgL,logSumm.yposBinsFine(1:end-1)+mode(diff(logSumm.yposBinsFine))/2,'r-')
ylim([-30 430]); xlim([-16.5 16.5])
box off; set(gca,'fontsize',10)
xlabel('x position (cm)','fontsize',12)
ylabel('y position (cm)','fontsize',12)
title('Trajectory','fontsize',13)

% plot raw view angle
subplot(3,3,[5 8]); hold on
plot([-5 5],[0 0],'-','color',[.7 .7 .7])
plot([-5 5],[-mazes(logSumm.mainMazeID).lStart -mazes(logSumm.mainMazeID).lStart],'-','color',[.7 .7 .7])
plot([-5 5],[mazes(logSumm.mainMazeID).lCue mazes(logSumm.mainMazeID).lCue],'-','color',[.7 .7 .7])
plot([-5 5],[mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory...
    mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
plot([-16 -5],[mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory ...
    mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
plot([5 16],[mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory ...
    mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
plot([-16 16],20+[mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory ...
    mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
plot([-16 -16],[mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory ...
    20+mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
plot([16 16],[mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory ...
    20+mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
plot([-5 -5],[-mazes(logSumm.mainMazeID).lStart ...
    mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
plot([5 5],[-mazes(logSumm.mainMazeID).lStart ...
    mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
for ii = 1:logSumm.ntrials
    if logSumm.choice(ii) == logSumm.rightCode
        plot(logSumm.pos{ii}(:,3),logSumm.pos{ii}(:,2),'linewidth',.25,'color',[.7 .7 1])
    else
        plot(logSumm.pos{ii}(:,3),logSumm.pos{ii}(:,2),'linewidth',.25,'color',[1 .7 .7])
    end
end
plot(logSumm.viewAvgR,logSumm.yposBinsFine(1:end-1)+mode(diff(logSumm.yposBinsFine))/2,'b-')
plot(logSumm.viewAvgL,logSumm.yposBinsFine(1:end-1)+mode(diff(logSumm.yposBinsFine))/2,'r-')
ylim([-30 450]); xlim([-70 70])
box off; set(gca,'fontsize',10,'xdir','reverse')
xlabel('view angle (deg)','fontsize',12)
ylabel('y position (cm)','fontsize',12)
title('View Angle','fontsize',13)

% plot binned view angle
subplot(3,3,[6 9]); hold on
plot([-5 5],[0 0],'-','color',[.7 .7 .7])
plot([-5 5],[-mazes(logSumm.mainMazeID).lStart -mazes(logSumm.mainMazeID).lStart],'-','color',[.7 .7 .7])
plot([-5 5],[mazes(logSumm.mainMazeID).lCue mazes(logSumm.mainMazeID).lCue],'-','color',[.7 .7 .7])
plot([-5 5],[mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory...
    mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
plot([-16 -5],[mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory ...
    mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
plot([5 16],[mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory ...
    mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
plot([-16 16],20+[mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory ...
    mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
plot([-16 -16],[mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory ...
    20+mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
plot([16 16],[mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory ...
    20+mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
plot([-5 -5],[-mazes(logSumm.mainMazeID).lStart ...
    mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
plot([5 5],[-mazes(logSumm.mainMazeID).lStart ...
    mazes(logSumm.mainMazeID).lCue+mazes(logSumm.mainMazeID).lMemory],'-','color',[.7 .7 .7])
bins = -70:5:70;
for jj = 1:length(logSumm.yposBinsCoarse)-1
    thishist = logSumm.viewL_coarseBinned(jj,:);
    if size(thishist,2) == size(bins,2)
        thishist(thishist==0 & (bins < -50 | bins > 50))=nan;
    else
        thishist(thishist==0 & (bins' < -50 | bins' > 50))=nan;
    end
    thishist = thishist*mode(diff(logSumm.yposBinsCoarse)) + logSumm.yposBinsCoarse(jj) + mode(diff(logSumm.yposBinsCoarse))/2; % add offset
    plot(bins+mode(diff(bins))/2,thishist,'r-')
    
    thishist = logSumm.viewR_coarseBinned(jj,:);
    if size(thishist,2) == size(bins,2)
        thishist(thishist==0 & (bins < -50 | bins > 50))=nan;
    else
        thishist(thishist==0 & (bins' < -50 | bins' > 50))=nan;
    end
    thishist = thishist*mode(diff(logSumm.yposBinsCoarse)) + logSumm.yposBinsCoarse(jj) + mode(diff(logSumm.yposBinsCoarse))/2; % add offset
    plot(bins+mode(diff(bins))/2,thishist,'b-')
end
ylim([-40 450]); xlim([-70 70])
box off; set(gca,'fontsize',10,'xdir','reverse')
xlabel('view angle (deg)','fontsize',12)
ylabel('y position (cm)','fontsize',12)
title('View Angle','fontsize',13)

set(gcf,'PaperUnits','inches','PaperPosition',[.8 1 7.2 8.9])
print(gcf,'-dpsc',sprintf('%s/%s_sessionData.ps',pwd,logSumm.mouseID),'-append')

%saveas(gcf,fn)
end
